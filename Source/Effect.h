// © 2024 Adam Badke. All rights reserved.
#pragma once
#include "PipelineState.h"
#include "Shader.h"

#include "Core\Interfaces\INamedObject.h"

using EffectID = NameID;
using TechniqueID = NameID;


namespace effect
{
	class Technique;
	class Effect;


	class DrawStyle
	{
	public:
		// TODO: This should be auto-generated by generating code from JSON as a pre-build step
		using Bitmask = uint64_t;
		static constexpr Bitmask k_defaultTechniqueBitmask = 0;

		static constexpr Bitmask GBuffer_Fill = 1llu << 0;

		static constexpr Bitmask AlphaMode_Opaque = 1llu << 1;
		static constexpr Bitmask AlphaMode_Mask = 1llu << 2;
		static constexpr Bitmask AlphaMode_Blend = 1llu << 3;
		
		static constexpr Bitmask MaterialSidedness_Single = 1llu << 4;
		static constexpr Bitmask MaterialSidedness_Double = 1llu << 5;

		static constexpr Bitmask Debug_Line = 1llu << 6;
		static constexpr Bitmask Debug_Triangle = 1llu << 7;

		static constexpr Bitmask Bloom_EmissiveBlit = 1llu << 8;

		static constexpr Bitmask DeferredLighting_BRDFIntegration = 1llu << 9;
		static constexpr Bitmask DeferredLighting_IEMGeneration = 1llu << 10;
		static constexpr Bitmask DeferredLighting_PMREMGeneration = 1llu << 11;
		static constexpr Bitmask DeferredLighting_DeferredAmbient = 1llu << 12;
		static constexpr Bitmask DeferredLighting_DeferredDirectional = 1llu << 13;
		static constexpr Bitmask DeferredLighting_DeferredPoint = 1llu << 14;
		static constexpr Bitmask DeferredLighting_DeferredSpot = 1llu << 15;

		static constexpr Bitmask XeGTAO_PrefilterDepths = 1llu << 16;
		static constexpr Bitmask XeGTAO_QualityLow = 1llu << 17;
		static constexpr Bitmask XeGTAO_QualityMed = 1llu << 18;
		static constexpr Bitmask XeGTAO_QualityHigh = 1llu << 19;
		static constexpr Bitmask XeGTAO_QualityUltra = 1llu << 20;
		static constexpr Bitmask XeGTAO_Denoise = 1llu << 21;
		static constexpr Bitmask XeGTAO_DenoiseLastPass = 1llu << 22;

		static constexpr Bitmask Shadow_2D = 1llu << 23;
		static constexpr Bitmask Shadow_Cube = 1llu << 24;


		using ModeToBitmask = std::unordered_map<std::string, effect::DrawStyle::Bitmask>;
		using DrawStyleRuleToModes = std::unordered_map<std::string, ModeToBitmask>;

	private:
		static DrawStyleRuleToModes const& GetDrawStyleRuleToModesMap()
		{
			static const DrawStyleRuleToModes s_drawstyleBitmaskMappings(
				{
					{
						"GBuffer",
						{
							{"Fill", effect::DrawStyle::GBuffer_Fill}
						}
					},
					{
						"MaterialAlphaMode",
						{
							{"Opaque", effect::DrawStyle::AlphaMode_Opaque},
							{"Mask", effect::DrawStyle::AlphaMode_Mask},
							{"Blend", effect::DrawStyle::AlphaMode_Blend},
						}
					},
					{
						"MaterialSidedness",
						{
							{"Single", effect::DrawStyle::MaterialSidedness_Single},
							{"Double", effect::DrawStyle::MaterialSidedness_Double},
						}
					},
					{
						"Debug",
						{
							{"Line", effect::DrawStyle::Debug_Line},
							{"Triangle", effect::DrawStyle::Debug_Triangle},
						}
					},
					{
						"Bloom",
						{
							{"EmissiveBlit", effect::DrawStyle::Bloom_EmissiveBlit},
						}
					},
					{
						"DeferredLighting",
						{
							{"BRDFIntegration", effect::DrawStyle::DeferredLighting_BRDFIntegration},
							{"IEMGeneration", effect::DrawStyle::DeferredLighting_IEMGeneration},
							{"PMREMGeneration", effect::DrawStyle::DeferredLighting_PMREMGeneration},
							{"DeferredAmbient", effect::DrawStyle::DeferredLighting_DeferredAmbient},
							{"DeferredDirectional", effect::DrawStyle::DeferredLighting_DeferredDirectional},
							{"DeferredPoint", effect::DrawStyle::DeferredLighting_DeferredPoint},
							{"DeferredSpot", effect::DrawStyle::DeferredLighting_DeferredSpot},
						}
					},
					{
						"XeGTAO",
						{
							{"PrefilterDepths", effect::DrawStyle::XeGTAO_PrefilterDepths},
							{"LowQuality", effect::DrawStyle::XeGTAO_QualityLow},
							{"MedQuality", effect::DrawStyle::XeGTAO_QualityMed},
							{"HighQuality", effect::DrawStyle::XeGTAO_QualityHigh},
							{"UltraQuality", effect::DrawStyle::XeGTAO_QualityUltra},
							{"Denoise", effect::DrawStyle::XeGTAO_Denoise},
							{"DenoiseLastPass", effect::DrawStyle::XeGTAO_DenoiseLastPass},
						}
					},
					{
						"Shadow",
						{
							{"2D", effect::DrawStyle::Shadow_2D},
							{"Cube", effect::DrawStyle::Shadow_Cube},
						}
					},
				});
			return s_drawstyleBitmaskMappings;
		}


	public:
		static Bitmask GetDrawStyleBitmaskByName(std::string const& drawstyleName, std::string const& mode)
		{
			DrawStyleRuleToModes const& drawstyleBitmaskMappings = GetDrawStyleRuleToModesMap();

			SEAssert(drawstyleBitmaskMappings.contains(drawstyleName) && 
				drawstyleBitmaskMappings.at(drawstyleName).contains(mode),
				"Draw style name or mode name not found");

			return drawstyleBitmaskMappings.at(drawstyleName).at(mode);
		}


		// Debug helper: Convert a bitmask back to a list of names
		static std::string GetNamesFromDrawStyleBitmask(Bitmask bitmask)
		{
			using BitmaskToEffectAndMode = std::unordered_map<effect::DrawStyle::Bitmask, std::string>;

			// Build a static reverse lookup map
			static BitmaskToEffectAndMode s_drawstyleBitmaskMappings;

			static std::atomic<bool> s_isInitialized = false;
			if (!s_isInitialized)
			{
				static std::mutex s_initializationMutex;

				{
					std::lock_guard<std::mutex> lock(s_initializationMutex);

					if (!s_isInitialized)
					{
						s_isInitialized.store(true);

						DrawStyleRuleToModes const& drawstyleBitmaskMappings = GetDrawStyleRuleToModesMap();

						for (auto const& effectEntry : drawstyleBitmaskMappings)
						{
							std::string const& effectName = effectEntry.first;

							for (auto const& modeBitmaskEntry : effectEntry.second)
							{
								std::string const& modeName = modeBitmaskEntry.first;
								const effect::DrawStyle::Bitmask bitmask = modeBitmaskEntry.second;

								s_drawstyleBitmaskMappings.emplace(bitmask, std::format("{}::{}", effectName, modeName));
							}
						}
					}
				}
			}

			// Concatenate the results:
			std::string names;
			constexpr uint8_t k_numBits = sizeof(Bitmask) * 8;
			for (uint8_t bitIdx = 0; bitIdx < k_numBits; ++bitIdx)
			{
				const Bitmask curBit = Bitmask(1) << bitIdx;
				if (bitmask & curBit)
				{
					names += s_drawstyleBitmaskMappings.at(curBit) + "|";
				}
			}
			return names;
		}
	};


	class Effect : public virtual core::INamedObject
	{
	public:
		static constexpr EffectID k_invalidEffectID = core::INamedObject::k_invalidNameID;

		static EffectID ComputeEffectID(std::string const& effectName);

	public:
		Effect(char const* name);

		Effect(Effect&&) = default;
		Effect& operator=(Effect&&) = default;

		~Effect() = default;

		bool operator==(Effect const&) const;


	public:
		EffectID GetEffectID() const;

		Technique const* GetResolvedTechnique(effect::DrawStyle::Bitmask) const;


	public:
		void AddTechnique(effect::DrawStyle::Bitmask, effect::Technique const*);


	private:
		std::unordered_map<effect::DrawStyle::Bitmask, effect::Technique const*> m_techniques;


	private:
		Effect(Effect const&) = delete;
		Effect& operator=(Effect const&) = delete;
	};


	inline EffectID Effect::ComputeEffectID(std::string const& effectName)
	{
		return core::INamedObject::ComputeIDFromName(effectName);
	}


	inline EffectID Effect::GetEffectID() const
	{
		return GetNameID();
	}


	inline Technique const* Effect::GetResolvedTechnique(effect::DrawStyle::Bitmask drawStyleBitmask) const
	{
		SEAssert(m_techniques.contains(drawStyleBitmask),
			std::format("No Technique matches the given Bitmask: {}", 
				effect::DrawStyle::GetNamesFromDrawStyleBitmask(drawStyleBitmask)).c_str());

		return m_techniques.at(drawStyleBitmask);
	}


	// ---


	class Technique : public virtual core::INamedObject
	{
	public:
		static constexpr EffectID k_invalidTechniqueID = core::INamedObject::k_invalidNameID;

		static TechniqueID ComputeTechniqueID(std::string const& techniqueName);


	public:
		Technique(
			char const* name, 
			std::vector<std::pair<std::string, re::Shader::ShaderType>> const&,
			re::PipelineState const*);
		
		Technique(Technique&&) = default;
		Technique& operator=(Technique&&) = default;

		~Technique() = default;

		bool operator==(Technique const&) const;


	public:
		TechniqueID GetTechniqueID() const;

		std::shared_ptr<re::Shader> GetShader() const;


	private:	
		std::shared_ptr<re::Shader> m_resolvedShader;


	private: // No copying allowed
		Technique(Technique const&) = delete;
		Technique& operator=(Technique const&) = delete;
	};


	inline TechniqueID Technique::ComputeTechniqueID(std::string const& techniqueName)
	{
		return core::INamedObject::ComputeIDFromName(techniqueName);
	}


	inline std::shared_ptr<re::Shader> Technique::GetShader() const
	{
		return m_resolvedShader;
	}
}