// © 2023 Adam Badke. All rights reserved.
#ifndef SABER_TRANSFORMATIONS
#define SABER_TRANSFORMATIONS


// Convert a linear depth in [near, far] (eye space) to a non-linear depth buffer value in [0,1]
float ConvertLinearDepthToNonLinear(const float near, const float far, const float depthLinear)
{
	const float depthNDC = (((2.0 * near * far) / depthLinear) - far - near) / (near - far);
	const float depthNonLinear = (depthNDC + 1.0) / 2.0;

	return depthNonLinear;
}


// Convert a non-linear depth in [0, 1] (e.g. from a depth buffer) to eye-space depth in [near, far]
// Note: Even in a RHCS looking down -Z, the eye-space [near, far] depth is positive. As demonstrated in this plot,
// negating the near/far values will result in a negative eye-space Z: https://www.desmos.com/calculator/urp2wvvmfm
float ConvertNonLinearDepthToLinear(float near, float far, float nonLinearDepth)
{
	return far * near / (far - nonLinearDepth * (far - near));
}


mat3 BuildLookAtMatrix(vec3 forward)
{
	const vec3 arbitraryUp = abs(forward.z) < 0.999f ? vec3(0, 0, 1) : vec3(1, 0, 0);
	
	const vec3 right = normalize(cross(arbitraryUp, forward));
	
	const vec3 up = normalize(cross(forward, right));
	
	return mat3(right, up, forward);
}


mat3 GetTransposeInvRotationScale(mat4 transposeInvModel)
{
	// Much simpler in GLSL than HLSL
	return mat3(transposeInvModel);
}


#endif // SABER_TRANSFORMATIONS