#ifndef SABER_COMMON
#define SABER_COMMON


// Common shader properties:
//--------------------------

struct VertexOut
{
// The GLSL compiler gets confused if we define an empty struct; Assume UV0 is always required
	vec2 UV0;

#if MAX_UV_CHANNEL_IDX >= 1
	vec2 UV1;
#endif

#ifdef VOUT_COLOR
	vec4 Color;
#endif

#ifdef VOUT_LOCAL_POS
	vec3 LocalPos; // Received Position: Local-space position
#endif

#ifdef VOUT_WORLD_POS
	vec3 WorldPos; // World-space position
#endif

#ifdef VOUT_TBN
	mat3 TBN; // Normal map change-of-basis matrix
#endif
};


#if !defined(HAS_OWN_VERTEX_OUTPUT_DECLARATION)
	#if defined(SE_VERTEX_SHADER)
		layout(location = 6) out VertexOut Out;
	#elif defined(SE_GEOMETRY_SHADER)
		layout(location = 6) in VertexOut In[];
		layout(location = 6) out VertexOut Out;
	#elif defined(SE_PIXEL_SHADER)
		layout(location = 6) in VertexOut In;
	#endif
#endif // !defined(HAS_OWN_VERTEX_OUTPUT_DECLARATION)


// Fragment shader outputs:
//-------------------------

#if defined(SE_PIXEL_SHADER) && !defined(HAS_OWN_FRAGMENT_OUTPUT_DECLARATION)
	#if defined(SABER_VEC2_OUTPUT)
		layout (location = 0) out vec2 FragColor;
	#elif defined(SABER_VEC3_OUTPUT)
		layout (location = 0) out vec3 FragColor;
	#elif defined(SABER_VEC4_OUTPUT)
		layout (location = 0) out vec4 FragColor;
	#endif
#endif
// TODO: These should all be defined locally in each shader


// Instancing:
#if defined(SABER_INSTANCING)
struct InstanceParams
{
	uint InstanceID;
};

	#if defined(SE_VERTEX_SHADER)
		layout(location = 5) flat out InstanceParams InstanceParamsOut;

	#elif defined(SE_GEOMETRY_SHADER)
		layout(location = 5) flat in InstanceParams InstanceParamsIn[];
		layout(location = 5) flat out InstanceParams InstanceParamsOut;

	#elif defined(SE_PIXEL_SHADER)		
		layout(location = 5) flat in InstanceParams InstanceParamsIn;

	#endif 
#endif // SABER_INSTANCING


#endif // SABER_COMMON